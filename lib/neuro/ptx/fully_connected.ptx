.version 4.3
.target sm_20
.address_size 64

.visible .entry fully_connected(
	.param .u64 .ptr .global input,  // %cd0
	.param .u64 .ptr .global w,      // %cd1
	.param .u64 .ptr .global output, // %cd2
	.param .u32 ix                   // %c0
)
{
  .reg .u64   %cd<3>;
  .reg .u32   %c<2>;
	.reg .u64 	%vd<1>;
	.reg .u32		%v<1>;
	.reg .f32 	%f<3>;
	.reg .pred	p;

  ld.param.u64 	%cd0, [input];
	ld.param.u64 	%cd1, [w];
	ld.param.u64 	%cd2, [output];
	ld.param.u32	%c0, [ix];
	mov.u32				%c1, %tid.x;

  // (%cd1) weight.offset = weight + tid.x * ix * 4
	mul.wide.u32 %vd0, %c1, %c0;
  mad.lo.u64 %cd1, %vd0, 4, %cd1;

  // (%cd2) output.offset = output + tid.x * 4
	mul.wide.u32 %vd0, %c1, 4;
	add.u64 %cd2, %cd2, %vd0;

  // %f0 - accumulator
  // %v0 - x count
  mov.f32 %f0, 0.0;
  mov.u32 %v0, %c0;
loop_x:
  ld.global.f32 %f1, [%cd0];
  ld.global.f32 %f2, [%cd1];
  // accumulator = accumulator + w[x]*input[x]
  mad.rn.f32 %f0, %f1, %f2, %f0;
  // next values
  add.u64 %cd0, %cd0, 4;
  add.u64 %cd1, %cd1, 4;
  // count x
  sub.u32     %v0, %v0, 1;
  setp.ne.u32 p, %v0, 0;
  @p bra      loop_x;

  // relu activation
  setp.lt.f32 p, %f0, 0.0;
  @p mov.f32 %f0, 0.0;

  st.global.f32 [%cd2], %f0;
  ret;
}
